/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   build_ui.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kearmand <kearmand@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/19 15:13:29 by kearmand          #+#    #+#             */
/*   Updated: 2025/12/19 16:46:11 by kearmand         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ui_int.h"
#include "ui_settings.h"

static const char	*ui_ssaa_txt(int idx)
{
	if (idx == UI_SSAA_IDX_MIN)
		return ("1");
	if (idx == UI_SSAA_IDX_MIN + 1)
		return ("4");
	if (idx == UI_SSAA_IDX_MIN + 2)
		return ("9");
	if (idx == UI_SSAA_IDX_MIN + 3)
		return ("16");
	return ("25");
}

static const char	*ui_onoff_txt(int enabled)
{
	if (enabled)
		return (UI_TXT_ON);
	return (UI_TXT_OFF);
}

static int	ui_is_mode_selected(t_ui *ui, int mode_idx)
{
	if (ui->mode_selected == mode_idx)
		return (1);
	return (0);
}

static void	ui_push_button(t_ui *ui, t_button *btn)
{
	ui->buttons[ui->button_count] = *btn;
	ui->button_count++;
}

static void	ui_add_close(t_ui *ui)
{
	t_button	btn;

	btn.x = UI_EXIT_X;
	btn.y = UI_EXIT_Y;
	btn.width = UI_EXIT_W;
	btn.height = UI_EXIT_H;
	btn.label = UI_BTN_CLOSE;
	btn.txt = UI_TXT_CLOSE;
	btn.color_bg = UI_COLOR_EXIT_BG;
	btn.color_txt = UI_COLOR_TEXT;
	ui_push_button(ui, &btn);
}

static void	ui_add_ssaa(t_ui *ui)
{
	t_button	btn;

	btn.x = UI_SSAA_MINUS_X;
	btn.y = UI_SSAA_MINUS_Y;
	btn.width = UI_SSAA_MINUS_W;
	btn.height = UI_SSAA_MINUS_H;
	btn.label = UI_BTN_SSAA_MINUS;
	btn.txt = UI_TXT_SSAA_MINUS;
	btn.color_bg = UI_COLOR_INACTIVE;
	btn.color_txt = UI_COLOR_TEXT;
	ui_push_button(ui, &btn);
	btn.x = UI_SSAA_VALUE_X;
	btn.y = UI_SSAA_VALUE_Y;
	btn.width = UI_SSAA_VALUE_W;
	btn.height = UI_SSAA_VALUE_H;
	btn.label = UI_BTN_SSAA_VALUE;
	btn.txt = ui_ssaa_txt(ui->ssaa_idx);
	btn.color_bg = UI_COLOR_VALUE_BG;
	btn.color_txt = UI_COLOR_VALUE_TEXT;
	ui_push_button(ui, &btn);
	btn.x = UI_SSAA_PLUS_X;
	btn.y = UI_SSAA_PLUS_Y;
	btn.width = UI_SSAA_PLUS_W;
	btn.height = UI_SSAA_PLUS_H;
	btn.label = UI_BTN_SSAA_PLUS;
	btn.txt = UI_TXT_SSAA_PLUS;
	btn.color_bg = UI_COLOR_INACTIVE;
	btn.color_txt = UI_COLOR_TEXT;
	ui_push_button(ui, &btn);
}

static void	ui_add_mode_lock(t_ui *ui)
{
	t_button	btn;

	btn.x = UI_MODE_LOCK_X;
	btn.y = UI_MODE_LOCK_Y;
	btn.width = UI_MODE_LOCK_W;
	btn.height = UI_MODE_LOCK_H;
	btn.label = UI_BTN_MODE_LOCK;
	btn.txt = UI_TXT_LOCK;
	btn.color_bg = ui_is_mode_selected(ui, UI_MODE_IDX_LOCK)
		? UI_COLOR_ACTIVE : UI_COLOR_INACTIVE;
	btn.color_txt = ui_is_mode_selected(ui, UI_MODE_IDX_LOCK)
		? UI_COLOR_TEXT_SELECTED : UI_COLOR_TEXT;
	ui_push_button(ui, &btn);
}

static void	ui_add_mode_roll(t_ui *ui)
{
	t_button	btn;

	btn.x = UI_MODE_ROLL_X;
	btn.y = UI_MODE_ROLL_Y;
	btn.width = UI_MODE_ROLL_W;
	btn.height = UI_MODE_ROLL_H;
	btn.label = UI_BTN_MODE_ROLL;
	btn.txt = UI_TXT_ROLL;
	btn.color_bg = ui_is_mode_selected(ui, UI_MODE_IDX_ROLL)
		? UI_COLOR_ACTIVE : UI_COLOR_INACTIVE;
	btn.color_txt = ui_is_mode_selected(ui, UI_MODE_IDX_ROLL)
		? UI_COLOR_TEXT_SELECTED : UI_COLOR_TEXT;
	ui_push_button(ui, &btn);
}

static void	ui_add_mode_free(t_ui *ui)
{
	t_button	btn;

	btn.x = UI_MODE_FREE_X;
	btn.y = UI_MODE_FREE_Y;
	btn.width = UI_MODE_FREE_W;
	btn.height = UI_MODE_FREE_H;
	btn.label = UI_BTN_MODE_FREE;
	btn.txt = UI_TXT_FREE;
	btn.color_bg = ui_is_mode_selected(ui, UI_MODE_IDX_FREE)
		? UI_COLOR_ACTIVE : UI_COLOR_INACTIVE;
	btn.color_txt = ui_is_mode_selected(ui, UI_MODE_IDX_FREE)
		? UI_COLOR_TEXT_SELECTED : UI_COLOR_TEXT;
	ui_push_button(ui, &btn);
}

static void	ui_add_tonemap_label(t_ui *ui)
{
	t_button	btn;

	btn.x = UI_TONEMAP_LABEL_X;
	btn.y = UI_TONEMAP_LABEL_Y;
	btn.width = UI_TONEMAP_LABEL_W;
	btn.height = UI_TONEMAP_LABEL_H;
	btn.label = UI_BTN_NONE;
	btn.txt = UI_TXT_TONEMAP;
	btn.color_bg = UI_COLOR_INACTIVE;
	btn.color_txt = UI_COLOR_TEXT;
	ui_push_button(ui, &btn);
}

static void	ui_add_tonemap_toggle(t_ui *ui)
{
	t_button	btn;

	btn.x = UI_TONEMAP_TOGGLE_X;
	btn.y = UI_TONEMAP_TOGGLE_Y;
	btn.width = UI_TONEMAP_TOGGLE_W;
	btn.height = UI_TONEMAP_TOGGLE_H;
	btn.label = UI_BTN_TONEMAP;
	btn.txt = ui_onoff_txt(ui->tonemap_enabled);
	btn.color_bg = ui->tonemap_enabled ? UI_COLOR_ACTIVE : UI_COLOR_INACTIVE;
	btn.color_txt = ui->tonemap_enabled
		? UI_COLOR_TEXT_SELECTED : UI_COLOR_TEXT;
	ui_push_button(ui, &btn);
}
static void	ui_add_apply(t_ui *ui)
{
	t_button	btn;

	btn.x = UI_APPLY_X;
	btn.y = UI_APPLY_Y;
	btn.width = UI_APPLY_W;
	btn.height = UI_APPLY_H;
	btn.label = UI_BTN_APPLY;
	btn.txt = UI_TXT_APPLY;
	btn.color_bg = UI_COLOR_ACTIVE;
	btn.color_txt = UI_COLOR_VALUE_TEXT;
	ui_push_button(ui, &btn);
}

void	ui_build_buttons(t_ui *ui)
{
	ui->button_count = 0;
	ui_add_close(ui);
	ui_add_tonemap_label(ui);
	ui_add_tonemap_toggle(ui);
	ui_add_ssaa(ui);
	ui_add_mode_lock(ui);
	ui_add_mode_roll(ui);
	ui_add_mode_free(ui);
	ui_add_apply(ui);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_ui.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kearmand <kearmand@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/19 11:20:00 by kearmand          #+#    #+#             */
/*   Updated: 2025/12/19 15:28:54 by kearmand         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ui_int.h"
#include "ui_settings.h"

typedef struct s_rect
{
	int	x;
	int	y;
	int	w;
	int	h;
	int	color;
}	t_rect;

static void	ui_put_pixel(t_image *img, int x, int y, int color)
{
	char	*dst;

	if (x < 0 || y < 0 || x >= img->width || y >= img->height)
		return ;
	dst = img->data + (y * img->size_l) + (x * (img->bpp / 8));
	*(unsigned int *)dst = (unsigned int)color;
}

static void	ui_fill_rect(t_image *img, t_rect *rect)
{
	int	xx;
	int	yy;

	yy = 0;
	while (yy < rect->h)
	{
		xx = 0;
		while (xx < rect->w)
		{
			ui_put_pixel(img, rect->x + xx, rect->y + yy, rect->color);
			xx++;
		}
		yy++;
	}
}

static void	ui_draw_base_fill(t_ui *ui)
{
	t_rect	rect;

	rect.x = 0;
	rect.y = 0;
	rect.w = ui->img.width;
	rect.h = ui->img.height;
	rect.color = UI_COLOR_BG;
	ui_fill_rect(&ui->img, &rect);
	rect.x = 0;
	rect.y = 0;
	rect.w = ui->img.width;
	rect.h = UI_HEADER_H;
	rect.color = UI_COLOR_INACTIVE;
	ui_fill_rect(&ui->img, &rect);
}

static void	ui_draw_base_border_h(t_ui *ui, int thickness)
{
	t_rect	rect;

	rect.x = 0;
	rect.y = 0;
	rect.w = ui->img.width;
	rect.h = thickness;
	rect.color = UI_COLOR_INACTIVE;
	ui_fill_rect(&ui->img, &rect);
	rect.x = 0;
	rect.y = ui->img.height - thickness;
	rect.w = ui->img.width;
	rect.h = thickness;
	ui_fill_rect(&ui->img, &rect);
}

static void	ui_draw_base_border_v(t_ui *ui, int thickness)
{
	t_rect	rect;

	rect.x = 0;
	rect.y = 0;
	rect.w = thickness;
	rect.h = ui->img.height;
	rect.color = UI_COLOR_INACTIVE;
	ui_fill_rect(&ui->img, &rect);
	rect.x = ui->img.width - thickness;
	rect.y = 0;
	rect.w = thickness;
	rect.h = ui->img.height;
	ui_fill_rect(&ui->img, &rect);
}

static void	ui_draw_base(t_ui *ui)
{
	int	thickness;

	thickness = UI_BORDER_THICKNESS;
	ui_draw_base_fill(ui);
	ui_draw_base_border_h(ui, thickness);
	ui_draw_base_border_v(ui, thickness);
}

static void	ui_draw_icon_plus(t_image *img, t_button *btn)
{
	t_rect	rect;

	rect.color = btn->color_txt;
	rect.x = btn->x + UI_ICON_PLUS_VX;
	rect.y = btn->y + UI_ICON_PLUS_VY;
	rect.w = UI_ICON_PLUS_VW;
	rect.h = UI_ICON_PLUS_VH;
	ui_fill_rect(img, &rect);
	rect.x = btn->x + UI_ICON_PLUS_HX;
	rect.y = btn->y + UI_ICON_PLUS_HY;
	rect.w = UI_ICON_PLUS_HW;
	rect.h = UI_ICON_PLUS_HH;
	ui_fill_rect(img, &rect);
}

static void	ui_draw_icon_minus(t_image *img, t_button *btn)
{
	t_rect	rect;

	rect.color = btn->color_txt;
	rect.x = btn->x + UI_ICON_MINUS_X;
	rect.y = btn->y + UI_ICON_MINUS_Y;
	rect.w = UI_ICON_MINUS_W;
	rect.h = UI_ICON_MINUS_H;
	ui_fill_rect(img, &rect);
}

static void	ui_draw_icon_cross(t_image *img, t_button *btn)
{
	int	i;

	i = UI_ICON_X_MARGIN;
	while (i < btn->width - UI_ICON_X_MARGIN)
	{
		ui_put_pixel(img, btn->x + i, btn->y + i, btn->color_txt);
		ui_put_pixel(img, btn->x + i, btn->y + i + 1, btn->color_txt);
		ui_put_pixel(img, btn->x + (btn->width - 1 - i),
			btn->y + i, btn->color_txt);
		ui_put_pixel(img, btn->x + (btn->width - 1 - i),
			btn->y + i + 1, btn->color_txt);
		i++;
	}
}

static void	ui_draw_one_button(t_ui *ui, t_button *btn)
{
	t_rect	rect;

	rect.x = btn->x;
	rect.y = btn->y;
	rect.w = btn->width;
	rect.h = btn->height;
	rect.color = btn->color_bg;
	ui_fill_rect(&ui->img, &rect);
	if (btn->label == UI_BTN_SSAA_PLUS)
		ui_draw_icon_plus(&ui->img, btn);
	else if (btn->label == UI_BTN_SSAA_MINUS)
		ui_draw_icon_minus(&ui->img, btn);
	else if (btn->label == UI_BTN_CLOSE)
		ui_draw_icon_cross(&ui->img, btn);
}

void	draw_ui(t_ui *ui)
{
	int	index;

	ui_draw_base(ui);
	index = 0;
	while (index < ui->button_count)
	{
		ui_draw_one_button(ui, &ui->buttons[index]);
		index++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_ui.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kearmand <kearmand@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/19 01:04:11 by kearmand          #+#    #+#             */
/*   Updated: 2025/12/19 15:38:56 by kearmand         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ui_int.h"
#include "ui_settings.h"
#include "mlx.h"
#include "display.h"

static void	ui_init_state(t_ui *ui)
{
	ui->visible = 0;
	ui->event = -1;
	ui->x = UI_POS_X_DEFAULT;
	ui->y = UI_POS_Y_DEFAULT;
	ui->dragging = 0;
	ui->button_count = 0;
	ui->mouse_was_down = 0;
	ui->ssaa_idx = 0;
	ui->tonemap_enabled = 0;
	ui->mode_selected = 0;
}

static void	ui_init_image(t_display *display)
{
	t_image	*img;

	img = &display->ui.img;
	img->width = UI_W;
	img->height = UI_H;
	img->img_ptr = mlx_new_image(display->mlx, img->width, img->height);
	img->data = mlx_get_data_addr(img->img_ptr,
			&img->bpp, &img->size_l, &img->endian);
}

void	init_ui(t_display *display)
{
	ui_init_state(&display->ui);
	ui_init_image(display);
	ui_build_buttons(&display->ui);
	display->flag_ui = 1;
	display->ui.dirty = 1;
}
#include "ui_int.h"
#include "ui_settings.h"
#include "display.h"
#include <stdio.h>

static int	ui_mouse_just_pressed(t_ui *ui, t_mouse_state *mouse)
{
	if (ui->mouse_was_down == 1)
		return (0);
	if (mouse->is_down == 0)
		return (0);
	if (mouse->button != MOUSE_BUTTON_LEFT)
		return (0);
	return (1);
}

static int	ui_mouse_in_header(t_ui *ui, t_mouse_state *mouse)
{
	if (mouse->current_x < ui->x || mouse->current_x > ui->x + ui->img.width)
		return (0);
	if (mouse->current_y < ui->y || mouse->current_y > ui->y + UI_HEADER_H)
		return (0);
	return (1);
}

static void	ui_try_start_drag(t_ui *ui, t_mouse_state *mouse)
{
	if (ui->dragging == 1)
		return ;
	if (!ui_mouse_just_pressed(ui, mouse))
		return ;
	if (!ui_mouse_in_header(ui, mouse))
		return ;
	ui->dragging = 1;
	mouse->anchor_x = mouse->current_x;
	mouse->anchor_y = mouse->current_y;
}

static int	ui_clamp_int(int value, int min_v, int max_v)
{
	if (value < min_v)
		return (min_v);
	if (value > max_v)
		return (max_v);
	return (value);
}

static int	ui_drag_step(t_display *display, t_mouse_state *mouse)
{
	int	new_x;
	int	new_y;
	int	max_x;
	int	max_y;

	new_x = display->ui.x + mouse->current_x - mouse->anchor_x;
	new_y = display->ui.y + mouse->current_y - mouse->anchor_y;
	mouse->anchor_x = mouse->current_x;
	mouse->anchor_y = mouse->current_y;
	max_x = display->main_img.width - display->ui.img.width;
	max_y = display->main_img.height - display->ui.img.height;
	display->ui.x = ui_clamp_int(new_x, 0, max_x);
	display->ui.y = ui_clamp_int(new_y, 0, max_y);
	if (mouse->is_down == 0)
		display->ui.dragging = 0;
	display->flag_img_buffer = 1;
	display->flag_ui = 1;
	return (1);
}

static int	ui_mouse_in_button(t_ui *ui, t_mouse_state *mouse, t_button *btn)
{
	int	x0;
	int	y0;

	x0 = ui->x + btn->x;
	y0 = ui->y + btn->y;
	if (mouse->current_x < x0 || mouse->current_x > x0 + btn->width)
		return (0);
	if (mouse->current_y < y0 || mouse->current_y > y0 + btn->height)
		return (0);
	return (1);
}

static int	ui_is_clickable(t_button *btn)
{
	if (btn->label == UI_BTN_NONE)
		return (0);
	if (btn->label == UI_BTN_SSAA_VALUE)
		return (0);
	return (1);
}

static int	ui_try_click_button(t_ui *ui, t_mouse_state *mouse)
{
	int	index;

	if (ui->dragging == 1 || ui->event != -1)
		return (0);
	if (!ui_mouse_just_pressed(ui, mouse))
		return (0);
	index = 0;
	while (index < ui->button_count)
	{
		printf("Checking button %d\n", ui->buttons[index].label);
		if (ui_is_clickable(&ui->buttons[index])
			&& ui_mouse_in_button(ui, mouse, &ui->buttons[index]))
		{
			printf("Button %d clicked\n", ui->buttons[index].label);
			ui->event = ui->buttons[index].label;
			mouse->is_down = 0;
			mouse->button = MOUSE_BUTTON_NONE;
			return (1);
		}
		index++;
	}
	return (0);
}

static void	ui_apply_event(t_ui *ui, int event_id)
{
	if (event_id == UI_BTN_CLOSE)
		ui->visible = 0;
	else if (event_id == UI_BTN_TONEMAP)
		ui->tonemap_enabled = !ui->tonemap_enabled;
	else if (event_id == UI_BTN_SSAA_MINUS && ui->ssaa_idx > UI_SSAA_IDX_MIN)
		ui->ssaa_idx--;
	else if (event_id == UI_BTN_SSAA_PLUS && ui->ssaa_idx < UI_SSAA_IDX_MAX)
		ui->ssaa_idx++;
	else if (event_id == UI_BTN_MODE_LOCK)
		ui->mode_selected = UI_MODE_IDX_LOCK;
	else if (event_id == UI_BTN_MODE_ROLL)
		ui->mode_selected = UI_MODE_IDX_ROLL;
	else if (event_id == UI_BTN_MODE_FREE)
		ui->mode_selected = UI_MODE_IDX_FREE;
}

static void	apply_event(t_display *display, t_ui *ui)
{
	int i;

	display->render_ssaa = ui->ssaa_idx;
	display->render_tonemap = ui->tonemap_enabled;
	display->flag_request_render = 1;
	display->cam_ctrl.mode = ui->mode_selected;
	display->ui.visible = 0;
	i = 0;
	while (i < display->total_cams)
	{
		display->frame[i].quality = 0;
		i++;
	}
}

static void	ui_commit_event(t_display *display)
{
	t_ui	*ui;

	ui = &display->ui;
	if (ui->event == -1)
		return ;
	ui_apply_event(ui, ui->event);
	if (ui->event == UI_BTN_APPLY)
		apply_event(display, ui);
	ui->event = -1;
	ui->dirty = 1;
	display->flag_ui = 1;
}

static void	ui_rebuild_if_needed(t_display *display)
{
	t_ui	*ui;

	ui = &display->ui;
	if (ui->dirty == 0)
		return ;
	ui_build_buttons(ui);
	draw_ui(ui);
	ui->dirty = 0;
	display->flag_ui = 1;
	display->flag_img_buffer = 1;
}

void	display_update_ui(t_display *display)
{
	t_ui			*ui;
	t_mouse_state	*mouse;

	ui = &display->ui;
	mouse = &display->mouse;
	if (ui->visible == 0)
		return ;
	ui_try_click_button(ui, mouse);
	ui_try_start_drag(ui, mouse);
	if (ui->dragging == 1)
		ui_drag_step(display, mouse);
	ui->mouse_was_down = mouse->is_down;
	ui_commit_event(display);
	ui_rebuild_if_needed(display);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ui_print.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kearmand <kearmand@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/19 01:53:49 by kearmand          #+#    #+#             */
/*   Updated: 2025/12/19 15:29:25 by kearmand         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ui_int.h"
#include "ui_settings.h"
#include "mlx.h"
#include "new_rt.h"

void	print_txt_ui(t_data *data)
{
	t_display	*display;
	t_ui		*ui;
	int			i;

	display = &data->display;
	ui = &display->ui;
	if (!ui->visible)
		return ;
	mlx_string_put(display->mlx, display->win,
		ui->x + 10, ui->y + 18, UI_COLOR_TEXT, "UI");
	i = 0;
	while (i < ui->button_count)
	{
		if (ui->buttons[i].txt)
		{
			mlx_string_put(display->mlx, display->win,
				ui->x + ui->buttons[i].x + 4,
				ui->y + ui->buttons[i].y + (ui->buttons[i].height / 2) + 4,
				ui->buttons[i].color_txt, ui->buttons[i].txt);
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ui_int.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kearmand <kearmand@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/19 01:50:29 by kearmand          #+#    #+#             */
/*   Updated: 2025/12/19 16:37:18 by kearmand         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef UI_INT_H
# define UI_INT_H

typedef struct s_display	t_display;
typedef struct s_data		t_data;

# include "image.h"

# define MAX_UI_BUTTONS 16

typedef enum e_ui_btn
{
	UI_BTN_NONE = -1,
	UI_BTN_CLOSE = 1,
	UI_BTN_TONEMAP,
	UI_BTN_SSAA_MINUS,
	UI_BTN_SSAA_VALUE,
	UI_BTN_SSAA_PLUS,
	UI_BTN_MODE_LOCK,
	UI_BTN_MODE_ROLL,
	UI_BTN_MODE_FREE,
	UI_BTN_APPLY

}	t_ui_btn;

typedef struct s_button
{
	int			x;
	int			y;
	int			width;
	int			height;
	int			label;
	const char	*txt;
	int			color_bg;
	int			color_txt;
}	t_button;

typedef struct s_ui
{
	int			visible;
	int			dirty;
	t_image		img;
	int			event;
	int			x;
	int			y;
	int			dragging;
	t_button	buttons[MAX_UI_BUTTONS];
	int			button_count;
	int			mouse_was_down;
	int			ssaa_idx;
	int			tonemap_enabled;
	int			mode_selected;
}	t_ui;

void	init_ui(t_display *display);
void	display_update_ui(t_display *display);
void	print_txt_ui(t_data *data);
void	draw_ui(t_ui *ui);
void	ui_build_buttons(t_ui *ui);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ui_settings.h                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kearmand <kearmand@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/19 01:10:48 by kearmand          #+#    #+#             */
/*   Updated: 2025/12/19 16:48:49 by kearmand         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef UI_SETTINGS_H
# define UI_SETTINGS_H

/* =========================
**  UI PANEL SIZE / POSITION
** ========================= */
# define UI_W 200
# define UI_H 160
# define UI_POS_X_DEFAULT 50
# define UI_POS_Y_DEFAULT 50
# define UI_HEADER_H 30

/* =========================
**  UI STATE / INDICES
** ========================= */
# define UI_MODE_IDX_LOCK 0
# define UI_MODE_IDX_ROLL 1
# define UI_MODE_IDX_FREE 2

# define UI_SSAA_IDX_MIN 0
# define UI_SSAA_IDX_MAX 4

/* =========================
**  COLORS
** ========================= */
typedef enum e_ui_color
{
	UI_COLOR_INACTIVE = 0x333333,
	UI_COLOR_ACTIVE = 0x00AAFF,
	UI_COLOR_TEXT = 0xFFFFFF,
	UI_COLOR_VALUE_BG = 0xDDDDDD,
	UI_COLOR_VALUE_TEXT = 0x000000,
	UI_COLOR_EXIT_BG = 0xFF2020,
	UI_COLOR_BG = 0x222222
}	t_ui_color;

# define UI_COLOR_TEXT_SELECTED UI_COLOR_VALUE_TEXT

/* =========================
**  TEXTS
** ========================= */
# define UI_TXT_CLOSE ""
# define UI_TXT_TONEMAP "Tonemap"
# define UI_TXT_SSAA_MINUS ""
# define UI_TXT_SSAA_PLUS ""
# define UI_TXT_LOCK "LOCK"
# define UI_TXT_ROLL "ROLL"
# define UI_TXT_FREE "FREE"
# define UI_TXT_ON "ON"
# define UI_TXT_OFF "OFF"

/* =========================
**  BUTTON LAYOUT
** ========================= */

/* Close button */
# define UI_EXIT_X 172
# define UI_EXIT_Y 5
# define UI_EXIT_W 20
# define UI_EXIT_H 20

/* Tonemap : label + toggle */
# define UI_TONEMAP_LABEL_X 10
# define UI_TONEMAP_LABEL_Y 40
# define UI_TONEMAP_LABEL_W 80
# define UI_TONEMAP_LABEL_H 16

# define UI_TONEMAP_GAP 6
# define UI_TONEMAP_TOGGLE_W 40
# define UI_TONEMAP_TOGGLE_H UI_TONEMAP_LABEL_H
# define UI_TONEMAP_TOGGLE_X (UI_TONEMAP_LABEL_X + UI_TONEMAP_LABEL_W \
	+ UI_TONEMAP_GAP)
# define UI_TONEMAP_TOGGLE_Y UI_TONEMAP_LABEL_Y

/* SSAA */
# define UI_SSAA_MINUS_X 10
# define UI_SSAA_MINUS_Y 70
# define UI_SSAA_MINUS_W 16
# define UI_SSAA_MINUS_H 16

# define UI_SSAA_VALUE_X 30
# define UI_SSAA_VALUE_Y 70
# define UI_SSAA_VALUE_W 40
# define UI_SSAA_VALUE_H 16

# define UI_SSAA_PLUS_X 75
# define UI_SSAA_PLUS_Y 70
# define UI_SSAA_PLUS_W 16
# define UI_SSAA_PLUS_H 16

/* Camera mode */
# define UI_MODE_LOCK_X 10
# define UI_MODE_LOCK_Y 100
# define UI_MODE_LOCK_W 50
# define UI_MODE_LOCK_H 16

# define UI_MODE_ROLL_X 65
# define UI_MODE_ROLL_Y 100
# define UI_MODE_ROLL_W 50
# define UI_MODE_ROLL_H 16

# define UI_MODE_FREE_X 120
# define UI_MODE_FREE_Y 100
# define UI_MODE_FREE_W 50
# define UI_MODE_FREE_H 16

/* Apply button */
# define UI_APPLY_W 60
# define UI_APPLY_H 18
# define UI_APPLY_X 70
# define UI_APPLY_Y 125
# define UI_TXT_APPLY "APPLY"



/* =========================
**  DRAW SETTINGS (ICONS / FRAME)
** ========================= */
# define UI_BORDER_THICKNESS 3

/* Plus icon (relative to button x/y) */
# define UI_ICON_PLUS_VX 7
# define UI_ICON_PLUS_VY 2
# define UI_ICON_PLUS_VW 2
# define UI_ICON_PLUS_VH 12
# define UI_ICON_PLUS_HX 2
# define UI_ICON_PLUS_HY 7
# define UI_ICON_PLUS_HW 12
# define UI_ICON_PLUS_HH 2

/* Minus icon (relative to button x/y) */
# define UI_ICON_MINUS_X 2
# define UI_ICON_MINUS_Y 7
# define UI_ICON_MINUS_W 12
# define UI_ICON_MINUS_H 2

/* Cross icon (relative to button x/y) */
# define UI_ICON_X_MARGIN 2

#endif